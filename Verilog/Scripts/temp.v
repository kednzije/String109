
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module EXP5(

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// Seg7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	output		     [6:0]		HEX2,
	output		     [6:0]		HEX3,
	output		     [6:0]		HEX4,
	output		     [6:0]		HEX5
);



//=======================================================
//  REG/WIRE declarations
//=======================================================

wire cntrInc0, cntrInc1;
reg [3:0] cntr[2];
reg rco[2];
reg [6:0] cntrS[2];

wire regclk, regwr;
wire [3:0] rb;
wire [3:0] rw;
reg [7:0] regouta;
reg [7:0] regoutb;
reg [6:0] regoutbS[2];

wire ramclk, ramwren;
wire [3:0] ramaddr;
wire [7:0] ramout;
reg [6:0] ramoutS[2];

//=======================================================
//  Structural coding
//=======================================================

counter cntr0(cntrInc0, 1'b1, 1'b1, 4'hf, cntr[0], rco[0]);
counter cntr1(cntrInc1, 1'b1, 1'b1, 4'hf, cntr[1], rco[1]);
bcd2seg cntrS0(cntr[0], 1'b1, cntrS[0]);
bcd2seg cntrS1(cntr[1], 1'b1, cntrS[1]);

regfile regf(4'h0, rb, rw, {cntr[1][3:0], cntr[0][3:0]}, regwr, regclk, regouta, regoutb);
bcd2seg regoutbS0(regoutb[3:0], 1'b1, regoutbS[0]);
bcd2seg regoutbS1(regoutb[7:4], 1'b1, regoutbS[1]);

ram1port ram(ramaddr, ramclk, {cntr[1][3:0], cntr[0][3:0]}, ramwren, ramout);
bcd2seg ramoutS0(ramout[3:0], 1'b1, ramoutS[0]);
bcd2seg ramoutS1(ramout[7:4], 1'b1, ramoutS[1]);

assign cntrInc0 = ~KEY[0];
assign cntrInc1 = ~KEY[1];

assign regclk = KEY[2];
assign regwr = ~SW[9];
assign rb = SW[3:0];
assign rw = SW[7:4];

assign ramclk = ~KEY[3];
assign ramwren = SW[9];
assign ramaddr = SW[3:0];

assign HEX0 = cntrS[0];
assign HEX1 = cntrS[1];
assign HEX2 = regoutbS[0];
assign HEX3 = regoutbS[1];
assign HEX4 = ramoutS[0];
assign HEX5 = ramoutS[1];

endmodule
